<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NUNF: Simulated Data Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NUNF<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">Generalized neutron unfolding library for cpp</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('simulated_example.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Simulated Data Example</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page walks you through a complete unfolding scenario using simulated neutron data so that you could see what an unfolding response would look like for an exact spectrum. A good portion of the code in this example is also contained in the <a class="el" href="experimental_measurement_example.html">Experimental Measurement Section</a>. This section is a little less thorough than the aforementioned section but should still be a sufficient example for the majority of use cases when testing simulated data. We do go into additional detail for functions that are unique to the simulated case. If you'd like to run it right off the bat, without reading the explanation, please go to the bottom of the page.</p>
<div class="image">
<img src="SimulatedStructure.png" alt=""/>
<div class="caption">
Figure 1:Simulated Measurement File Structure</div></div>
<p> An example project folder structure is listed in Figure 1. In the directory there is the main file, which takes two of the api classes, <a class="el" href="classUNFOLD_1_1UNFOLD.html">UNFOLD::UNFOLD</a> and UNFOLD::FILEIO, and initializes them as singleton objects. Please note, that the file name of the project is the exact same as its class name. This is necessary to do if wanting to implement your own main class using the components given in the library. This is a root construct for macros and is necessary for compilation. <br  />
Next there are two folders, one for imports and another for exports. In case you'd like to dig through the code, modules used in the UNFOLD and FILEIO objects are listed in the figure as well.<br  />
 </p><h1>Code Walkthrough </h1>
<p>To begin please go to the root of the package if you are not already. Now open the file ./examples/Simulated_Measurement_Unfolding_Example/Simulated_Measurement_Unfolding_Example.C using vim or any other file editor of you preference. </p><pre class="fragment"> vim examples/Simulated_Measurement_Unfolding_Example/Simulated_Measurement_Unfolding_Example.C
</pre><p> We refer the reader to the comments. This page will walk the user through the code, making references to labeled code block numbers. We again note that a large portion of this code is in the <a class="el" href="experimental_measurement_example.html">Experimental Measurement Section</a>. As such, code labeled "Code Block &lt;#&gt;: Please Refer to Code Block &lt;#&gt; in Experimental Example", will not be described for this section. The code blocks labeled with "Code block &lt;#&gt;:" are specific to this example.</p>
<h2>Code Block 1</h2>
<pre class="fragment">UNFOLD::FILEIO *fio;
fio = new UNFOLD::FILEIO();
</pre><p> This group of code creates the class that will handle reading in data. The main functionality of this class is covered in this section. Please see <a class="el" href="classUNFOLD_1_1FILEIO.html">FILEIO</a> for more features.<br  />
<br  />
 </p><h2>Code block 2:</h2>
<pre class="fragment">fio-&gt;setResponse("./Simulated_Measurement_Unfolding_Example/imports/odessa_matrix.txt",0,0,0,0.05,0.01)
</pre><p> The first step is to read in the response matrix. This methood reads in a text file for the matrix. The parameters are as follows: <br  />
</p><ul>
<li>The path to the file</li>
<li>Whether or not the file has neutron energy bins as its rows (1) or columns (0)</li>
<li>The start value for the neutron energy bin edge in MeV</li>
<li>The start value for the light output bin edge in MeVee</li>
<li>The neutron energy bin width in MeV</li>
<li>The light output bin width in MeVee.<br  />
</li>
</ul>
<h2>Code Block 3:</h2>
<pre class="fragment">  fio-&gt;setThresholdLO(0.03);
  //note we do not normalize to efficiency here, and that is okay.
  fio-&gt;normalizeResponseToOne();
  fio-&gt;setThreshold(0.01);
</pre><p>This block of code shows various operations on the matrix before unfolding. SetThresholdLO sets the response matrix rows (the light output axis) to 0 if the bin edge lies under the threshold. I.e. if you have lo bin edges (0,1,2,3....) and the threshold lo is 1.3, values in the 0th and 1st bin of your response matrix in the lO axis will be set to 0. The line fio-&gt;normalizeResponseToOne() loops through each neutron energy bin, aka response matrix column, and takes the integral of each one. It then divides every bin within a single neutron energy by the integral of its column. <br  />
 We highlight that we did not normalize to efficiency. Maybe it was already part of the file. Or maybe, you just don't want to normalize to efficiency. Either way, you don't have to. <br  />
fio-&gt;set threshold does NOT affect the response matrix. It is a structure that gets passed into the <a class="el" href="classUNFOLD_1_1UNFOLD.html">UNFOLD.cc</a> class and sets the algorithmic guess for bins under the threshold to 0. <br  />
<br  />
</p>
<h2>Code Block 4:</h2>
<pre class="fragment">     //After importing, Create an Unfold object which takes the structures from FILEIO and performs the unfolding
    //includes 
    //response matrix
    //initialization of the first StopIndice for iteration 0 in the unfolding
    //a necessary function for the algorithm. Just call it please
    //initial guess for the unfolding

    UNFOLD::UNFOLD s(fio);
    std::cout &lt;&lt; "setting response matrix\n";
    s.setResponseMatrix();
    cout &lt;&lt; "calculating normal matrix\n";
    s.printParameters();

    s.calcNormMatrix();
    s.setInitialGuess(1.);
</pre><p>Before code block 4, all the structures had been setup in FILEIO for an experimental measurement. The next step is to initialize the <a class="el" href="classUNFOLD_1_1UNFOLD.html">UNFOLD::UNFOLD</a> class. The constructor takes in a FILEIO object. FILEIO served as the middleman to read in soem of the unfolding structures but the UNFOLD object itself needs to set the structures from the FILEIO object. As a reselt, s.setResponse() and s.setInputSpectrum() are called. <br  />
<br  />
 The two functions below it are additional functions needed for unfolding. The first function just initializes a factor for the algorithm but is dependant on the response and input spectrum. As such, it requires the user to call it after the two aforementioned structures have been initialized. The second function initializes the answer which will be iterated upon in the unfolding algorithm</p>
<h2>Code Block 5:</h2>
<pre class="fragment">  //Code Block 5 Creating fake neutron data
  //en is the energy bin low edge 
  //w is the number of counts in each bin
  vector&lt;double&gt; en = {1.2,1.8,1.9,2.55,3.7,5.5};
  vector&lt;double&gt;  w = {300,1500,500,630,1200,2200};
  s.generateFakeData(en, w);
  cout &lt;&lt; "setting initial guess\n";
</pre><p>This block of code is for creating synthetic neutron data. The way it works is by creating a vector of bin edges and a vector of counts for the neutron energy bin corresponding to that bin edge. Note, the bin edge would be the lower bin edge. I.e. if in your response matrix, you have neutron bin edges of (0,1,2,3,4,5,6 .... and for the 3rd element in w and en, you give a count of 500 and 2.2 respectively, the third bin in the neutron energy spectrum would have a count of 500. That third bin has 2 as its lower edge. <br  />
<br  />
</p>
<h2>Code Block 6-9:</h2>
<pre class="fragment">  //Code Block 6 defining a maximum iteration count stop
 for(int i=0; i&lt;70; i++)
  {
    //Code Block 7 The various update methods
    s.updateMLEM();
    //s.updateGRAVEL();
    //s.updateSIRT();

    //Code Block 8 
    //STOP INDEX 1  from https://www.osti.gov/pages/servlets/purl/1770936
    //If you'd like to log the stopIndex uncomment this line. Please note this doesn't affect anything in the unfold object, it just calcs the index
    //cout&lt;&lt;"current iteration stop index "&lt;&lt; s.calcstopIndex()&lt;&lt;std::endl;
    //
    //If you'd like to use it to stop the unfolding, uncomment this line
    //if(s.calcstopIndex() &lt; 1) {break;}

    //To update the current iteration of the stop index this NEEDS to be called. This is used for plotting later on in the program
    //
    //___________NOTE FOR SIMULATED EXAMPLE!______ While it does update the stop index, seen from its name, it also updates the RMSE and needs to be called if you want to plot or export that value vs. iteration.  TODO: RENAME like UPDATE ITERATION BASED VARIABLES
    s.updateStopIndices();


    //Code Block 9 
    //STOP INDEX 2 FROM https://www.sciencedirect.com/science/article/abs/pii/S0920379622002769?via%3Dihub
    //If you'd like to log the stopIndex uncomment this line. Please note this doesn't affect anything in the unfold object, it just calcs the index
    //NOTE THIS CALCULATION TAKES THE FIRST TWO ITERATIONS TO CALCULATE THE STOP INDEX AND WILL SPIT OUT A NEGATIVE NUMBER TILL THE s.updateStopIndices() IS CALLED TWICE
    //cout&lt;&lt;"current iteration stop index "&lt;&lt; s.calcDeltaStopIndex()&lt;&lt;std::endl;
    //
    //If you'd like to use it to stop the unfolding, uncomment this line note it is always positive unless using it before the second iteration
    //if(s.calcDeltaStopIndex() &lt; 1 &amp;&amp; s.calcDeltaStopIndex() &gt; 0) {break;}
    //
    //does not need an update function. It gets updated in the calcDeltaStopIndex() function

  }
</pre><p>This code is the exact same as the code block 5-8 in the section <a class="el" href="experimental_measurement_example.html">Experimental Measurement Section</a> and we point the reader to read that section. While we haven't introduced RMSE yet, this function needs to be called to update the RMSE metric which compares the ground truth vs. the current iteration's guess. We highlight this as the ground truth and the RMSE are concepts only for simulated data.</p>
<h2>Code Block 10:</h2>
<pre class="fragment">    s.plotAnswer("Neutron Spectrum");
  s.exportAnswer("./Simulated_Measurement_Unfolding_Example/exports/answer_dt_only_neutrons_w_protons_hist_scaled_2pnt_07_07_2023.txt");

  s.plotProjection("lightOutput");
  s.exportForwardProjection("./Simulated_Measurement_Unfolding_Example/exports/projection.txt");



  //This group of plotting functions is described in the experimental example.
  /*s.plotResponseMatrix();
  s.plotResponseMatrix2D();
  s.exportResponseMatrix("./Simulated_Measurement_Unfolding_Example/exports/conformed_response_matrix.txt",1);

  s.plotResiduals();
  s.exportResiduals("./Simulated_Measurement_Unfolding_Example/exports/residuals.txt");

  s.plotStopIndices();
  s.exportStopIndices("./Simulated_Measurement_Unfolding_Example/exports/stop_indices.txt");

  s.plotDeltaStopIndices();
  s.exportDeltaStopIndices("./Simulated_Measurement_Unfolding_Example/exports/delta_stop_indices.txt");
  */
</pre><p>This is a set of functions for plotting and exporting the final outputs. We leave this code block to be explained by Code Block 9 in in the <a class="el" href="experimental_measurement_example.html">Experimental Measurement Section</a> as it is the same exact code. However, we did comment out some of the functions to unclutter the output when this example is ran.</p>
<h2>Code Block 11:</h2>
<pre class="fragment">  //This is a function that will plot the RMSE vs. iteration. This is only for simulated data.
  s.plotRMSE();
  //This is a function that will export the RMSE vs. iteration. This is only for simulated data.
  s.exportRMSE("./Simulated_Measurement_Unfolding_Example/exports/rmse.txt");\
</pre><p>We want to highlight the RMSE plot and export and separated it form the other output functions. This is a metric that compares the ground truth to the current iteration's guess. This is only for simulated data. <br  />
<br  />
 </p>
<h1><a class="anchor" id="running_the_program_2"></a>
Running the Program</h1>
<p>To run the example file that was described in this page, ./examples/Simulated_Measurement_Unfolding_Example/Simulated_Measurement_Unfolding_Example.C, please go to the root directory of the entire package. From there change into the examples folder using </p><pre class="fragment">cd examples
</pre><p> Then run </p><pre class="fragment">bash kill_and_build.sh Simulated_Measurement_Unfolding_Example/Simulated_Measurement_Unfolding_Example.C
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Getting Started</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
