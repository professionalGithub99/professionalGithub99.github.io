<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NUNF: Experimental Measurement Unfolding Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NUNF<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">Generalized neutron unfolding library for cpp</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('experimental_measurement_example.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Experimental Measurement Unfolding Example</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page walks you through a complete unfolding scenario using actual expiremental data from an actual measurment. The example pieces together different components of the package to show how one might implement different classes and methods in a main class. Note, the parts of the package implemented in this page covers the full scope of unfolding if using experimental data. It is not just another watered down "basic example" description that is impractical for actual use; Just following the instructions on this page would suffice for the majority of unfolding use cases.<br  />
If you'd like to run it right off the bat, without reading the explanation, please go to the bototm of the page.</p>
<h1>Class Interface and Descriptions </h1>
<p>Below is a diagram of the structure of a typical program. </p><div class="image">
<img src="ExperimentalStructure.png" alt=""/>
<div class="caption">
Figure 1:Experimental Measurement File Structure</div></div>
<p>An example project folder structure is listed in Figure 1. In the directory there is the main file, which takes two of the api classes, <a class="el" href="classUNFOLD_1_1UNFOLD.html">UNFOLD::UNFOLD</a> and UNFOLD::FILEIO, and initializes them as singleton objects. Please note, that the file name of the project is the same as its class name. This is necessary to do if wanting to implement your own main class using the components given in the library. This is a root construct for macros and is necessary for compilation. <br  />
Next there are two folders, one for imports and another for exports. In case you'd like to dig through the code, modules used in the UNFOLD and FILEIO objects are listed in the figure as well.<br  />
 </p><h1>Code Walkthrough </h1>
<p>To begin please go to the root of the package if you are not already. Now open the file ./examples/Experimental_Measurement_Unfolding_Example/Experimental_Measurement_Unfolding_Example.C. </p><pre class="fragment"> vim examples/Experimental_Measurement_Unfolding_Example/Experimental_Measurement_Unfolding_Example.C
</pre><p> We refer the reader to the comments. This page will walk the user through the code, making references to labeled code block numbers. While there may be multiple choices for a certain action such as reading in a file of multiple formats, we give one option may highlight another in the comments with an explanation. Some options may require a skim through the documentation.<br  />
<br  />
 </p><h2>Code block 1:</h2>
<pre class="fragment">UNFOLD::FILEIO *fio;
fio = new UNFOLD::FILEIO();
</pre><p> This group of code creates the class that will handle reading in data. The main functionality of this class is covered in this section. Please see <a class="el" href="classUNFOLD_1_1FILEIO.html">FILEIO</a> for more features.<br  />
<br  />
 </p><pre class="fragment">## Code block 2: ##

    fio-&gt;setResponse("./Experimental_Measurement_Unfolding_Example/imports/response_matrices/EJ301D_D_and_P_TrackingTo55MeV0.1NEBins0.0025LOBins.txt",0,0,0,0.1,0.0025);
    //fio-&gt;setResponseFromTH2("./Full_Unfolding_Example/imports/response_matrices/EJ301D_D_and_P_TrackingTo55MeV0.1NEBins0.0025LOBins.root");
</pre><p>The first step is to read in the response matrix. The first method, reads in a text file for the matrix. The parameters are as follows: <br  />
</p><ul>
<li>The path to the file</li>
<li>Whether or not the file has neutron energy bins as its rows (1) or columns (0)</li>
<li>The start value for the neutron energy bin edge in MeV</li>
<li>The start value for the light output bin edge in MeVee</li>
<li>The neutron energy bin width in MeV</li>
<li>The light output bin width in MeVee. <br  />
</li>
</ul>
<p>The second method, reads in a root file for the matrix. This method is simple such that it only requires the path to the file. For now, it assumes the columns are neutron energy bins and the rows are light output bins. <br  />
</p>
<h2>Code Block 2a:</h2>
<pre class="fragment">float p0 = 572.0/1000.;
float p1 = 2394.0/1000.;
float p2 = 200.0/1000.;
float fraction = 1.0;
fio-&gt;conformBinning(p0,p1,p2,fraction);
</pre><p> This block of code is used for conformal binning. It is explained in detail in <a href="https://pubs.aip.org/aip/jap/article-abstract/120/6/064501/144074/Warhead-verification-as-inverse-problem?redirectedFrom=fulltext">https://pubs.aip.org/aip/jap/article-abstract/120/6/064501/144074/Warhead-verification-as-inverse-problem?redirectedFrom=fulltext</a>. The method we use to rebin requires the user to input very fine bin edges. When bins are split or rebinned, the edges may not align with the original edges. This creates errors in accuracy of counts in light output bin axis. While with conformal binning, it isn't avoidable, using finer bin spacing in the light output dimension minimizes the errors. <br  />
 </p><h2>Code Block 2b:</h2>
<pre class="fragment">fio-&gt;normalizeResponseToOne();
fio-&gt;readInEfficiency("./Experimental_Measurement_Unfolding_Example/imports/EfficiencyTo55MeV.root","hist");
fio-&gt;setThresholdLO(0.16);
</pre><p> NOTE When wanting to normalize to efficiency, you must have both normalizeResponseToOne() and readInEfficiency() called before setResponseMatrix() is called If you want to normalize to one, comment out ONLY readInEfficiency()</p>
<p>This block of code shows some other operations on the matrix before unfolding. The first two lines of code normalizes the matrix. Typical methods include normalizing to one or to the efficiency. Normalizing to the efficiency requires both normalization to one, than passing in an efficiency file of every neutron energy bin in the detector. The matrix is then multiplied accordingly.<br  />
 If you want to only normalize to one, comment out the fio-&gt;readInEfficiency(....) line.<br  />
<br  />
 SetThresholdLO sets the response matrix rows (the light output axis) to 0 if the bin edge lies under the threshold. I.e. if you have lo bin edges (0,1,2,3....) and the threshold lo is 1.3, values in the 0th and 1st bin of your response matrix in the lO axis will be set to 0.</p>
<h2>Code Block 3 Setting the input spectrum:</h2>
<pre class="fragment">fio-&gt;readInExpSpectrumRebin("./Experimental_Measurement_Unfolding_Example/imports/dt_only_neutrons_w_protons_hist_scaled_2pnt_07_07_2023.root","newHist");
</pre><p> This method of setting the input spectrum does a bin check between the light output input spectrum and the response matrix light output bin edges. If the bin edges do not match, the program will exit. <br  />
 For this case, since we used conformal binning, the input spectrum is almost garunteed to not match the response matrix bin edges as the original root processing of the input spectrum certainly would not rebin to that interval. fio-&gt;readInExpSpectrum("./Experimental_Measurement_Unfolding_Example/imports/dt_only_neutrons_w_protons_hist_scaled_2pnt_07_07_2023.root","newHist"); </p><pre class="fragment">fio-&gt;setThreshold(0.5);
</pre><p> In this step, the input spectrum is set from a root file. A histogram name does need to be passed in, for the second parameter. The input spectrum gets rebinned in relation to the response matrix's bin edge. We suggest if you know the bin edges are not going to match, you use extremely fine light output bin edges otherwise errors in bin splitting grows with size of the original bins. The commented version of reading the input spectrum does a bin check between the light output bin edges and the response matrix bin edge. <br  />
<br  />
We put set threshold in this code block, separated from setThresholdLO because we want to emphasize that setting the threshold does NOT affect the response matrix. It is a structure that gets passed into the <a class="el" href="classUNFOLD_1_1UNFOLD.html">UNFOLD.cc</a> class and sets the algorithmic guess for bins under the threshold to 0.</p>
<h2>Code Block 4:</h2>
<pre class="fragment">UNFOLD::UNFOLD s(fio);
std::cout &lt;&lt; "setting response matrix\n";
s.setResponseMatrix();
s.setInSpectrum();
s.printParameters();

s.calcNormMatrix();
s.setInitialGuess(1.);
</pre><p> Before code block 4, all the structures had been setup in FILEIO for an experimental measurement. The next step is to initialize the <a class="el" href="classUNFOLD_1_1UNFOLD.html">UNFOLD::UNFOLD</a> class. The constructor takes in a FILEIO object. FILEIO served as the middleman to read in soem of the unfolding structures but the UNFOLD object itself needs to set the structures from the FILEIO object. As a reselt, s.setResponse() and s.setInputSpectrum() are called. <br  />
<br  />
 The two functions below it are additional functions needed for unfolding. The first function just initializes a factor for the algorithm but is dependant on the response and input spectrum. As such, it requires the user to call it after the two aforementioned structures have been initialized. The second line initializes the answer that will be iterated upon.</p>
<h2>Code Block 5 - 8 unfolding:</h2>
<pre class="fragment">    //Code Block 5
    for(int i=0; i&lt;70; i++)
    {

      //Code Block 6 The various update methods
      s.updateMLEM();
      //s.updateGRAVEL();
      //s.updateSIRT();

      //Code Block 7 
      //STOP INDEX 1  from https://www.osti.gov/pages/servlets/purl/1770936 equation 6.
      //
      //If you'd like to log the stopIndex uncomment this line. Please note this doesn't affect anything in the unfold object, it just calcs the index
      //cout&lt;&lt;"current iteration stop index "&lt;&lt; s.calcstopIndex()&lt;&lt;std::endl;
      //
      //If you'd like to use it to stop the unfolding, uncomment this line
      //if(s.calcstopIndex() &lt; 1) {break;}
      //
      //To update the current iteration of the stop index call this function. This is used for plotting later on in the program
      s.updateStopIndices();


      //Code Block 8
      //STOP INDEX 2 FROM https://www.sciencedirect.com/science/article/abs/pii/S0920379622002769?via%3Dihub
      //If you'd like to log the stopIndex uncomment this line. Please note this doesn't affect anything in the unfold object, it just calcs the index
      //NOTE THIS CALCULATION TAKES THE FIRST TWO ITERATIONS TO CALCULATE THE STOP INDEX AND WILL SPIT OUT A NEGATIVE NUMBER TILL THE s.updateStopIndices() IS CALLED TWICE
      //cout&lt;&lt;"current iteration stop index "&lt;&lt; s.calcDeltaStopIndex()&lt;&lt;std::endl;
      //
      //If you'd like to use it to stop the unfolding, uncomment this line note it is always positive unless using it before the second iteration
      //if(s.calcDeltaStopIndex() &lt; 1 &amp;&amp; s.calcDeltaStopIndex() &gt; 0) {break;}
      //
      //does not need an update function. It gets updated in the calcDeltaStopIndex() function

    }
</pre><p> We explain code blocks 5 - 8 below to allow the user to see the full scope of the unfolding process. <br  />
 </p><h3>Code Block 5 explanation:</h3>
<p>The for loop is meant to be a stopping criteria based on a maximum iteration count. This can still be used with other criteria however requiring a break statement if hit which is shown in code block 7 and code block 8, where multiple stopping criteria are defined and able to break out of the loop if hit. <br  />
<br  />
 </p><h3>Code Block 6 explanation:</h3>
<p>On each unfolding iteration, the user must select one update method which modifies the guess spectrum based on the response matrix, the input spectrum and the current guess. In this code we have available three options. This includes the simultaneous iterative reconstruction technique (SIRT), maximum-likelihood expectation-maximization (MLEM), and GRAVEL.</p>
<h3>Code Block 7 explanation:</h3>
<p>In this block, the first cout statement allows the user to print out the stop index from the paper <a href="https://www.osti.gov/pages/servlets/purl/1770936">https://www.osti.gov/pages/servlets/purl/1770936</a> in Equation 6. The second statement is for using the index to break out the loop. Some papers dictate that J &lt;= 1 implies criteria for stopping. Others dictate that the quantity for J to stop depends on the size of the neutron statistics. As such, this feature is experimental and can be uncommented if the user desires. The final statement is necessary for plotting J and also for the stopping criteria in code block 8. If you don't plan on either, comment out the line.</p>
<h3>Code Block 8 explanation:</h3>
<p>In this block of code, the first cout statement allows the user to print out the stop index from the paper <a href="https://www.sciencedirect.com/science/article/abs/pii/S0920379622002769?via%3Dihub">https://www.sciencedirect.com/science/article/abs/pii/S0920379622002769?via%3Dihub</a> equation 11. It is defined as the difference in J between iteration k and k-1. It returns a negative number if s.updateStopIndice has been called less than 2 times.</p>
<h2>Code Block 9:</h2>
<pre class="fragment">s.plotAnswer("Neutron Spectrum");
s.exportAnswer("./Experimental_Measurement_Unfolding_Example/exports/answer_dt_only_neutrons_w_protons_hist_scaled_2pnt_07_07_2023.txt");

s.plotProjection("lightOutput");
s.exportForwardProjection("./Experimental_Measurement_Unfolding_Example/exports/projection.txt");

s.plotResponseMatrix();
s.plotResponseMatrix2D();
s.exportResponseMatrix("./Experimental_Measurement_Unfolding_Example/exports/conformed_response_matrix.txt",1);

s.plotResiduals();
s.exportResiduals("./Experimental_Measurement_Unfolding_Example/exports/residuals.txt");

s.plotStopIndices();
s.exportStopIndices("./Experimental_Measurement_Unfolding_Example/exports/stop_indices.txt");

s.plotDeltaStopIndices();
s.exportDeltaStopIndices("./Experimental_Measurement_Unfolding_Example/exports/delta_stop_indices.txt");
</pre><p> This set of code is used for plotting and exporting the results of the unfolding. When running the example using the command below, graphs will pop up with self explanatory titles matching the plot functions in code block 9. The exported files can be found in the file path is intputted as the parameter in the code block. Note these directories are relative to the examples directory where the script to compiile and run the programs is. Go to <a class="el" href="experimental_measurement_example.html#running_the_program">Running the Program</a> for further clarification. <br  />
</p>
<h1><a class="anchor" id="running_the_program"></a>
Running the Program</h1>
<p>To run the example file that was described in this page, ./examples/Experimental_Measurement_Unfolding_Example/Experimental_Measurement_Unfolding_Example.C, please go to the root directory of the entire package.From there change into the examples folder using </p><pre class="fragment">cd examples
</pre><p> Then run </p><pre class="fragment">bash kill_and_build.sh Experimental_Measurement_Unfolding_Example/Experimental_Measurement_Unfolding_Example.C
</pre><p> This command automatically kills all root processes from previous runs and simultaneously compiles the example file. It then executes whatever the main program is called relative to the examples directory. Congrats you have unfolded the neutron spectrum from a experimental measurement! <br  />
</p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Getting Started</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
